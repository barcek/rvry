#!/bin/bash

# rvry v1.17.2
# Â©2022 barcek
# License: MIT
# @ github.com
# /barcek/rvry

# Assumes the presence of Bash in '/bin', plus AWK (Gawk),
# cat, date, fold, head, sed, tail and tput

# Loops, waiting for $beat seconds for use of the $sign key,
# printing one $mark and incrementing $path by 1 each cycle;
# if either an $edge set to greater than 0 steps is reached
# or either $sign or Ctrl-C is pressed, prints the duration
# w/ any $tag, and if any $log appends all w/ a start stamp,
# then if any $task runs w/ any $word being the full output,
# else if $glimpse is set prints the flow w/ current values

mark=. # characters printed
path=0 # initial step count
beat=1 # secs between steps
edge=0 # if >0, steps taken
sign=q # key pressed to end
word=:RVRY # cue for output

# define help text generator

lead() {
  lines=$(head -n 25 $1 | tail -n 17 | sed 's/$/\\n/')
  echo "Usage: rvry [ [ --mark/-m <chars> | --path/-p <steps> | --beat/-b <secs> | --edge/-e <steps> |"
  echo "                --deep/-d | --sign/-s <key> | --word/-w <chars> | --task/-t <cmd: str/src> ]"
  echo "              [ --glimpse/-g ] [tag [log]] / --help/-h / --version/-v ]"
  echo "Initial:"
  echo -e $lines | sed 's/^ //g' | tail -n 7 | head -n 6 | sed 's/^/ /' | sed 's/=/ = /' | sed 's/# /(/' | sed 's/$/)/'
  echo "Summary:"
  echo -e $lines | sed 's/^ //g' | head -n 10 | tail -n 7 | sed 's/#//'  | sed 's/\$//g'
  echo "Context:"
  echo -e $lines | sed 's/^ //g' | head -n 2 | sed 's/#//'
}

# define success and failure exit managers

ease() {
  tput cnorm # show cursor
  exit 0
}

jolt() {
  echo "$1" >&2
  tput cnorm # show cursor
  exit 1
}

# handle any arguments provided

arg_i=1
slips=()

while (( $arg_i <= ${#} )); do

  case "${@: $arg_i:1}" in

    "--help"|"-h")
      # show help text then exit
      lead $0
      ease
      ;;

    "--version"|"-v")
      # show name and version number then exit
      line=$(head -n 3 $0 | tail -n 1)
      echo "${line: 2:12}"
      ease
      ;;

    "--mark"|"-m")
      # set $mark to the value of the next argument
      mark="${@: $arg_i+1:1}"
      ((arg_i++))
      ;;

    "--path"|"-p")
      # set $path to the value of the next argument
      path=${@: $arg_i+1:1}
      ((arg_i++))
      ;;

    "--beat"|"-b")
      # set $beat to the value of the next argument
      beat=${@: $arg_i+1:1}
      ((arg_i++))
      ;;

    "--edge"|"-e")
      # set $edge to the value of the next argument
      edge=${@: $arg_i+1:1}
      ((arg_i++))
      ;;

    "--sign"|"-s")
      # set $sign to the value of the next argument
      sign="${@: $arg_i+1:1}"
      ((arg_i++))
      ;;

    "--deep"|"-d")
      # omit the printing of $mark; cf. function step
      mark=""
      ;;

    "--word"|"-w")
      # set $word to the value of the next argument
      word="${@: $arg_i+1:1}"
      ((arg_i++))
      ;;

    "--task"|"-t")
      # set $task to the value of the next argument
      # or, if a file path, the content of the file
      if [ -f "${@: $arg_i+1:1}" ]; then
        task=$(cat "${@: $arg_i+1:1}")
      else
        task="${@: $arg_i+1:1}"
      fi
      ((arg_i++))
      ;;

    "--glimpse"|"-g")
      # interrupt to print flow w/ current values
      glimpse=true
      ;;

    --*|-*)
      # extend $slips with unavailable flag
      slips+=("'${@: $arg_i:1}'")
      ;;

    *)
      break
      ;;
  esac

  ((arg_i++))
done

slips_n=${#slips[@]}

if (( $slips_n > 0 )); then
  # produce one error for all flags
  root="No option for flag"
  case $slips_n in
    1) jolt "$root $slips";;
    2) jolt "$root ${slips[0]} or ${slips[1]}";;
    *) jolt "$root $(echo ${slips[@]: 0:${#slips[@]}-1} | sed 's/ /, /g') or ${slips[${#slips[@]}-1]}";;
  esac
fi

if [ -n "${@: $arg_i:1}" ]; then
  # set $tag to label the final output
  tag=${@: $arg_i:1}
fi

if [ -n "${@: $arg_i+1:1}" ]; then
  # set $log file path and start datetime stamp $dt0
  # to be persisted with duration and $tag;
  # cf. wake process functions
  log=${@: $arg_i+1:1}
  dt0=$(date)
fi

# define interruption functions

warn() {

  # print flow w/ current values

  if [ "1"  =  "$beat" ]; then part_beat="Once a second"; else part_beat="Every $beat seconds"; fi
  if [ ""   =  "$mark" ]; then part_mark="an empty string"; else part_mark="'$mark'"; fi
  if [  0  -lt  $edge  ]; then part_path=" and increments a count starting at $path"; part_edge=" or the count reaches $edge"; fi
  if [ -n      "$task" ]; then part_task=", then runs '$task'"; used_word=$(echo $task | grep $word); fi
  if [ -n "$used_word" ]; then part_word=", w/ '$word' being the full output"; fi
  if [ -n "$tag"  ]; then part_tag=" w/ '$tag'"; fi
  if [ -n "$log"  ]; then part_log=" and appends both w/ a start stamp to '$log'"; fi

  flow="${part_beat} prints ${part_mark}${part_path}, until either '${sign}' or Ctrl-C is pressed${part_edge}, then prints the duration ${part_tag}${part_log}${part_task}${part_word}"

  echo "$(echo $flow | fold -s -w 65)"
  ease
}

# define primary loop functions

heed() {
  # invoke wake process handler if $sign pressed
  read -t $beat -N 1 char
  if [ "$sign" == "$char" ]; then
    wake
  fi
}

step() {
  # print $mark if not empty and increment $path
  if [ -n "$mark" ]; then
    echo -n "${mark}"
  fi
  ((path++))
}

pass() {
  # call primary loop functions
  heed
  step
}

# define wake process functions

form() {

  # return duration based on $path and $beat, with $tag if set

  # calculate duration units, allowing for floating point $beat
  secs=$(echo "$path $beat" | awk '{print $1 * $2}')
  h_rm=$(echo "$secs 86400 3600" | awk '{print $1 % $2 / $3}')
  m_rm=$(echo "$secs 3600 60" | awk '{print $1 % $2 / $3}')
  s_rm=$(echo "$secs 60" | awk '{print $1 % $2}')

  view=$(printf "%02.f:%02.f:%02.f" $h_rm $m_rm $s_rm)

  if [ -n "$tag" ]; then
    view+=" ${tag}"
  fi

  echo "${view}"
}

show() {
  # write parameter no. 1 over current line
  wipe="\033[2K\r"
  echo -ne "$wipe"
  echo "$1"
}

keep() {
  # append parameter no. 1 to $log if set
  if [ -z "$log" ]; then
    return
  fi
  echo "$1" >> "$log"
}

call() {
  # pass $task if set as a command to Bash,
  # each $word replaced by parameter no. 1
  if [ -z "$task" ]; then
    return
  fi
  task=$(echo "$task" | sed "s/$word/$1/g")
  echo "$task"
  bash -c "$task"
}

wake() {
  # handle wake process then exit
  view=$(form)
  show "$view"
  keep "$dt0 $view"
  call "$dt0 $view"
  ease
}

# initiate

trap "wake" SIGINT

tput civis # hide cursor

if [ "true" = "$glimpse" ]; then warn; fi

if (( 0 == $edge )); then
  while true; do
    pass
  done
else
  while (( $path < $edge )); do
    pass
  done
  wake
fi
