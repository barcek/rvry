#!/bin/bash

# rvry v1.15.2
# Â©2022 barcek
# License: MIT
# @ github.com
# /barcek/rvry

# loops, waiting for $beat seconds for use of the $sign key,
# printing one $mark and incrementing $path by 1 each cycle;
# if either an $edge set to greater than 0 steps is reached
# or either $sign or Ctrl-C is pressed, prints the duration
# w/ any $tag, and if any $log appends all w/ a start stamp,
# then if any $task runs w/ any $word being the full output

mark=. # characters printed
path=0 # initial step count
beat=1 # secs between steps
edge=0 # if >0, steps taken
sign=q # key pressed to end
word=:RVRY # cue for output

# set help text

usage_ln_1="Usage: rvry [ [ --deep/-d | --beat/-b <secs> | --path/-p <steps> | --edge/-e <steps> | --mark/-m <char(s)>"
usage_ln_2="                --word <char(s)> | --task/-t <cmd: str/src> ] [tag [log]] / --help/-h / --version/-v ]"

help_text="${usage_ln_1}\n${usage_ln_2}"

# define error handler

jolt() {
  echo "$1" >&2
  exit 1
}

# handle any arguments provided

arg_i=1
slips=()

while (( $arg_i <= ${#} )); do

  case "${@: $arg_i:1}" in

    "--help"|"-h")
      # show help text then exit
      echo -e "$help_text"
      exit 0
      ;;

    "--version"|"-v")
      # show name and version number then exit
      cd "${0%/*}" || jolt "Unable to handle option for flag '${@: $arg_i:1}'"
      v=$(head -n 3 rvry | tail -n 1)
      echo "${v:2:12}"
      exit 0
      ;;

    "--deep"|"-d")
      # omit the printing of $mark; cf. function step
      mark=""
      ;;

    "--beat"|"-b")
      # set $beat to the value of the next argument
      beat=${@: $arg_i+1:1}
      ((arg_i++))
      ;;

    "--path"|"-p")
      # set $path to the value of the next argument
      path=${@: $arg_i+1:1}
      ((arg_i++))
      ;;

    "--edge"|"-e")
      # set $edge to the value of the next argument
      edge=${@: $arg_i+1:1}
      ((arg_i++))
      ;;

    "--mark"|"-m")
      # set $mark to the value of the next argument
      mark="${@: $arg_i+1:1}"
      ((arg_i++))
      ;;

    "--word"|"-w")
      # set $word to the value of the next argument
      word="${@: $arg_i+1:1}"
      ((arg_i++))
      ;;

    "--task"|"-t")
      # set $task to the value of the next argument
      # or, if a file path, the content of the file
      if [ -f "${@: $arg_i+1:1}" ]; then
        task=$(cat "${@: $arg_i+1:1}")
      else
        task="${@: $arg_i+1:1}"
      fi
      ((arg_i++))
      ;;

    --*|-*)
      # extend $slips with unavailable flag
      slips+=("'${@: $arg_i:1}'")
      ;;

    *)
      break
      ;;
  esac

  ((arg_i++))
done

slips_n=${#slips[@]}

if (( $slips_n > 0 )); then
  # produce one error for all flags
  root="No option for flag"
  case $slips_n in
    1) jolt "$root $slips";;
    2) jolt "$root ${slips[0]} or ${slips[1]}";;
    *) jolt "$root $(echo ${slips[@]: 0:${#slips[@]}-1} | sed 's/ /, /g') or ${slips[${#slips[@]}-1]}";;
  esac
fi

if [ -n "${@: $arg_i:1}" ]; then
  # set $tag to label the final output
  tag=${@: $arg_i:1}
fi

if [ -n "${@: $arg_i+1:1}" ]; then
  # set $log file path and start datetime stamp $dt0
  # to be persisted with duration and $tag;
  # cf. wake process functions
  log=${@: $arg_i+1:1}
  dt0=$(date)
fi

# define primary loop functions

heed() {
  # invoke wake process handler if $sign pressed
  read -t $beat -N 1 char
  if [ "$sign" == "$char" ]; then
    wake
  fi
}

step() {
  # print $mark if not empty and increment $path
  if [ -n "$mark" ]; then
    echo -n "${mark}"
  fi
  ((path++))
}

pass() {
  # call primary loop functions
  heed
  step
}

# define wake process functions

form() {

  # return duration based on $path and $beat, with $tag if set

  # calculate duration units, allowing for floating point $beat
  secs=$(echo "$path $beat" | awk '{print $1 * $2}')
  h_rm=$(echo "$secs 86400 3600" | awk '{print $1 % $2 / $3}')
  m_rm=$(echo "$secs 3600 60" | awk '{print $1 % $2 / $3}')
  s_rm=$(echo "$secs 60" | awk '{print $1 % $2}')

  view=$(printf "%02.f:%02.f:%02.f" $h_rm $m_rm $s_rm)

  if [ -n "$tag" ]; then
    view+=" ${tag}"
  fi

  echo "${view}"
}

show() {
  # write parameter no. 1 over current line
  wipe="\033[2K\r"
  echo -ne "$wipe"
  echo "$1"
}

keep() {
  # append parameter no. 1 to $log if set
  if [ -z "$log" ]; then
    return
  fi
  echo "$1" >> "$log"
}

call() {
  # pass $task if set as a command to Bash,
  # each $word replaced by parameter no. 1
  if [ -z "$task" ]; then
    return
  fi
  task=$(echo "$task" | sed "s/$word/$1/g")
  echo "$task"
  bash -c "$task"
}

wake() {
  # handle wake process then exit
  view=$(form)
  show "$view"
  keep "$dt0 $view"
  tput cnorm # show cursor
  call "$dt0 $view"
  exit 0
}

# initiate

trap "wake" SIGINT

tput civis # hide cursor

if (( 0 == $edge )); then
  while true; do
    pass
  done
else
  while (( $path < $edge )); do
    pass
  done
  wake
fi
