#!/bin/bash

# rvry v 1.7.1
# Â©2022 barcek
# License: MIT
# @ github.com
# /barcek/rvry

# loops, waiting for $beat seconds for use of the $sign key,
# printing one $mark and incrementing $path by 1 each cycle;
# if either $sign or Ctrl-C is pressed, prints the duration
# w/ any $tag, and if any $log appends all w/ a start stamp

mark=. # characters printed
path=0 # initial step count
beat=1 # secs between steps
sign=q # key pressed to end

# handle any arguments provided

usage="Usage: rvry [[--deep/-d | --beat/-b <secs> | --path/-p <steps> | --mark/-m <char(s)>] [tag [log]] / --help/-h / --version/-v]"
arg_i=1

while (( $arg_i <= ${#} )); do

  if [ "${@: $arg_i:1}" == "--help" ] || [ "${@: $arg_i:1}" == "-h" ]; then
    # show usage then exit
    echo $usage
    exit 0

  elif [ "${@: $arg_i:1}" == "--version" ] || [ "${@: $arg_i:1}" == "-v" ]; then
    # show name and version then exit
    cd "${0%/*}"
    v=$(head -n 3 rvry | tail -n 1)
    echo ${v:2:12}
    exit 0

  elif [ "${@: $arg_i:1}" == "--deep" ] || [ "${@: $arg_i:1}" == "-d" ]; then
    # omit the printing of $mark; cf. function step
    mark=""

  elif [ "${@: $arg_i:1}" == "--beat" ] || [ "${@: $arg_i:1}" == "-b" ]; then
    # set $beat to the value of the next argument
    beat=${@: $arg_i+1:1}
    ((arg_i++))

  elif [ "${@: $arg_i:1}" == "--path" ] || [ "${@: $arg_i:1}" == "-p" ]; then
    # set $path to the value of the next argument
    path=${@: $arg_i+1:1}
    ((arg_i++))

  elif [ "${@: $arg_i:1}" == "--mark" ] || [ "${@: $arg_i:1}" == "-m" ]; then
    # set $mark to the value of the next argument
    mark="${@: $arg_i+1:1}"
    ((arg_i++))

  else
    break
  fi

  ((arg_i++))
done

if ! [ -z "${@: $arg_i:1}" ]; then
  # set $tag to label the final output
  tag=${@: $arg_i:1}
fi

if ! [ -z "${@: $arg_i+1:1}" ]; then
  # set $log to append with a start datetime stamp $dt0,
  # the duration and $tag; cf. wake process functions
  log=${@: $arg_i+1:1}
  dt0=$(date)
fi

# define primary loop functions

heed() {
  read -t $beat -N 1 char
  if [ $sign == "$char" ]; then
    wake
  fi
}

step() {
  if [ -n "$mark" ]; then
    echo -n "${mark}"
  fi
  ((path++))
}

# define wake process functions

form() {

  # calculate units for $view, allowing for floating point $beat
  secs=$(echo "$path $beat" | awk '{print $1 * $2}')
  h_rm=$(echo "$secs 86400 3600" | awk '{print $1 % $2 / $3}')
  m_rm=$(echo "$secs 3600 60" | awk '{print $1 % $2 / $3}')
  s_rm=$(echo "$secs 60" | awk '{print $1 % $2}')

  view=$(printf "%02.f:%02.f:%02.f" $h_rm $m_rm $s_rm)

  if [ -n "$tag" ]; then
    view+=" ${tag}"
  fi

  echo "${view}"
}

keep() {
  if [ -n "$log" ]; then
    echo $dt0 $1 >> $log
  fi
}

show() {
  wipe="\033[2K\r"
  echo -ne $wipe
  echo $1
}

wake() {
  view=$(form)
  keep "$view"
  show "$view"
  exit 0
}

# initiate

trap "wake" SIGINT

while [ true ]; do
  heed
  step
done
